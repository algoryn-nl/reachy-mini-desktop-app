#!/bin/bash

# Script to build and sign update files
# Usage: ./scripts/build-update.sh [dev|prod] [version]
#
# With createUpdaterArtifacts: true in tauri.conf.json, Tauri automatically generates:
# - Windows: *.msi.zip + *.msi.zip.sig
# - Linux: *.AppImage.tar.gz + *.AppImage.tar.gz.sig  
# - macOS: *.app.tar.gz + *.app.tar.gz.sig
#
# This script finds these files and generates the latest.json manifest.

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(cd "$SCRIPT_DIR/../.." && pwd)"
cd "$PROJECT_DIR"

# Colors
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Configuration
ENV="${1:-dev}"
VERSION="${2:-}"
RELEASES_DIR="releases"
DEV_RELEASES_DIR="test-updates"

# Check arguments
if [ "$ENV" != "dev" ] && [ "$ENV" != "prod" ]; then
    echo -e "${RED}âŒ Usage: $0 [dev|prod] [version]${NC}"
    exit 1
fi

# Get version from tauri.conf.json if not provided
if [ -z "$VERSION" ]; then
    VERSION=$(grep -o '"version": "[^"]*"' src-tauri/tauri.conf.json | cut -d'"' -f4)
    if [ -z "$VERSION" ]; then
        echo -e "${RED}âŒ Unable to retrieve version from tauri.conf.json${NC}"
        exit 1
    fi
fi

echo -e "${BLUE}ðŸš€ Building update manifest for ${ENV} environment${NC}"
echo -e "${BLUE}   Version: ${VERSION}${NC}"
echo ""

# Determine output directory
if [ "$ENV" = "dev" ]; then
    OUTPUT_DIR="$DEV_RELEASES_DIR"
else
    OUTPUT_DIR="$RELEASES_DIR"
fi

# Create output directory
mkdir -p "$OUTPUT_DIR"

# Detect platform
PLATFORM=""
if [ -n "$TARGET_TRIPLET" ]; then
    if [[ "$TARGET_TRIPLET" == *"aarch64-apple-darwin"* ]]; then
        PLATFORM="darwin-aarch64"
    elif [[ "$TARGET_TRIPLET" == *"x86_64-apple-darwin"* ]]; then
        PLATFORM="darwin-x86_64"
    elif [[ "$TARGET_TRIPLET" == *"x86_64-pc-windows-msvc"* ]]; then
        PLATFORM="windows-x86_64"
    elif [[ "$TARGET_TRIPLET" == *"x86_64-unknown-linux-gnu"* ]]; then
        PLATFORM="linux-x86_64"
    fi
fi

# Fallback to OS detection
if [ -z "$PLATFORM" ]; then
    if [[ "$OSTYPE" == "darwin"* ]]; then
        ARCH=$(uname -m)
        if [ "$ARCH" = "arm64" ]; then
            PLATFORM="darwin-aarch64"
        else
            PLATFORM="darwin-x86_64"
        fi
    elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
        PLATFORM="linux-x86_64"
    elif [[ "$OSTYPE" == "msys" ]] || [[ "$OSTYPE" == "win32" ]]; then
        PLATFORM="windows-x86_64"
    else
        echo -e "${RED}âŒ Unsupported platform: $OSTYPE${NC}"
        exit 1
    fi
fi

echo -e "${BLUE}ðŸ“¦ Platform: ${PLATFORM}${NC}"

# Determine bundle directory
if [ -n "$TARGET_TRIPLET" ]; then
    if [ "$ENV" = "dev" ]; then
        BUNDLE_DIR="src-tauri/target/$TARGET_TRIPLET/debug/bundle"
    else
        BUNDLE_DIR="src-tauri/target/$TARGET_TRIPLET/release/bundle"
    fi
else
    if [ "$ENV" = "dev" ]; then
        BUNDLE_DIR="src-tauri/target/debug/bundle"
    else
        BUNDLE_DIR="src-tauri/target/release/bundle"
    fi
fi

# Make bundle dir absolute
if [[ "$BUNDLE_DIR" != /* ]]; then
    BUNDLE_DIR="$PROJECT_DIR/$BUNDLE_DIR"
fi

echo -e "${BLUE}ðŸ“‚ Bundle directory: ${BUNDLE_DIR}${NC}"

# Find the updater artifact generated by Tauri (createUpdaterArtifacts: true)
# These are auto-generated with signatures
UPDATER_FILE=""
SIGNATURE=""
FILE_NAME=""

if [[ "$PLATFORM" == darwin-* ]]; then
    # macOS: Look for .app.tar.gz (Tauri auto-generated)
    MACOS_DIR="$BUNDLE_DIR/macos"
    if [ -d "$MACOS_DIR" ]; then
        UPDATER_FILE=$(find "$MACOS_DIR" -name "*.app.tar.gz" -type f 2>/dev/null | head -1)
        if [ -n "$UPDATER_FILE" ] && [ -f "$UPDATER_FILE" ]; then
            SIG_FILE="${UPDATER_FILE}.sig"
            if [ -f "$SIG_FILE" ]; then
                FILE_NAME=$(basename "$UPDATER_FILE")
                echo -e "${GREEN}âœ… Found macOS updater artifact: ${FILE_NAME}${NC}"
            fi
        fi
    fi
    
elif [[ "$PLATFORM" == windows-* ]]; then
    # Windows MSI: Tauri generates .msi + .msi.sig (NOT .msi.zip)
    # The updater uses the .msi directly with its signature
    MSI_DIR="$BUNDLE_DIR/msi"
    if [ -d "$MSI_DIR" ]; then
        # Look for .msi file (not .msi.zip)
        UPDATER_FILE=$(find "$MSI_DIR" -name "*.msi" -type f ! -name "*.sig" 2>/dev/null | head -1)
        if [ -n "$UPDATER_FILE" ] && [ -f "$UPDATER_FILE" ]; then
            SIG_FILE="${UPDATER_FILE}.sig"
            if [ -f "$SIG_FILE" ]; then
                FILE_NAME=$(basename "$UPDATER_FILE")
                echo -e "${GREEN}âœ… Found Windows MSI updater artifact: ${FILE_NAME}${NC}"
            fi
        fi
    fi
    
    # Also check for NSIS (.nsis.zip) if MSI not found
    if [ -z "$UPDATER_FILE" ] || [ ! -f "$UPDATER_FILE" ]; then
        NSIS_DIR="$BUNDLE_DIR/nsis"
        if [ -d "$NSIS_DIR" ]; then
            UPDATER_FILE=$(find "$NSIS_DIR" -name "*.nsis.zip" -type f 2>/dev/null | head -1)
            if [ -n "$UPDATER_FILE" ] && [ -f "$UPDATER_FILE" ]; then
                SIG_FILE="${UPDATER_FILE}.sig"
                if [ -f "$SIG_FILE" ]; then
                    FILE_NAME=$(basename "$UPDATER_FILE")
                    echo -e "${GREEN}âœ… Found Windows NSIS updater artifact: ${FILE_NAME}${NC}"
                fi
            fi
        fi
    fi
    
elif [[ "$PLATFORM" == linux-* ]]; then
    # Linux: Look for .AppImage.tar.gz (Tauri auto-generated with createUpdaterArtifacts)
    APPIMAGE_DIR="$BUNDLE_DIR/appimage"
    if [ -d "$APPIMAGE_DIR" ]; then
        UPDATER_FILE=$(find "$APPIMAGE_DIR" -name "*.AppImage.tar.gz" -type f 2>/dev/null | head -1)
        if [ -n "$UPDATER_FILE" ] && [ -f "$UPDATER_FILE" ]; then
            SIG_FILE="${UPDATER_FILE}.sig"
            if [ -f "$SIG_FILE" ]; then
                FILE_NAME=$(basename "$UPDATER_FILE")
                echo -e "${GREEN}âœ… Found Linux updater artifact: ${FILE_NAME}${NC}"
            fi
        fi
    fi
fi

# Check if we found the updater file
if [ -z "$UPDATER_FILE" ] || [ ! -f "$UPDATER_FILE" ]; then
    echo -e "${RED}âŒ Updater artifact not found!${NC}"
    echo -e "${YELLOW}   Expected Tauri to generate updater artifacts with createUpdaterArtifacts: true${NC}"
    echo -e "${YELLOW}   Looking in: ${BUNDLE_DIR}${NC}"
    echo ""
    echo -e "${YELLOW}   Bundle directory contents:${NC}"
    ls -la "$BUNDLE_DIR" 2>/dev/null || echo "   Directory not found"
    echo ""
    
    # Show platform-specific directory
    if [[ "$PLATFORM" == darwin-* ]]; then
        echo -e "${YELLOW}   macOS bundle contents:${NC}"
        ls -la "$BUNDLE_DIR/macos" 2>/dev/null || echo "   Directory not found"
    elif [[ "$PLATFORM" == windows-* ]]; then
        echo -e "${YELLOW}   Windows MSI bundle contents:${NC}"
        ls -la "$BUNDLE_DIR/msi" 2>/dev/null || echo "   Directory not found"
    elif [[ "$PLATFORM" == linux-* ]]; then
        echo -e "${YELLOW}   Linux AppImage bundle contents:${NC}"
        ls -la "$BUNDLE_DIR/appimage" 2>/dev/null || echo "   Directory not found"
    fi
    exit 1
fi

# Check signature file
if [ ! -f "$SIG_FILE" ]; then
    echo -e "${RED}âŒ Signature file not found: ${SIG_FILE}${NC}"
    echo -e "${YELLOW}   Make sure createUpdaterArtifacts is enabled and signing key is configured${NC}"
    exit 1
fi

# Read signature (Tauri generates base64-encoded signatures)
echo -e "${BLUE}ðŸ” Reading signature from: ${SIG_FILE}${NC}"
SIGNATURE=$(cat "$SIG_FILE" | tr -d '\n\r')

# Verify signature is not empty
if [ -z "$SIGNATURE" ]; then
    echo -e "${RED}âŒ Signature file is empty${NC}"
    exit 1
fi

echo -e "${GREEN}âœ… Signature loaded (${#SIGNATURE} chars)${NC}"

# Copy updater file to releases directory
echo -e "${BLUE}ðŸ“‹ Copying updater artifact to ${OUTPUT_DIR}/${NC}"
cp "$UPDATER_FILE" "$OUTPUT_DIR/"
cp "$SIG_FILE" "$OUTPUT_DIR/"

# Generate download URL
if [ "$ENV" = "dev" ]; then
    FILE_URL="http://localhost:8080/${FILE_NAME}"
else
    if [ -n "$RELEASE_URL_BASE" ]; then
        FILE_URL="${RELEASE_URL_BASE}${VERSION}/${FILE_NAME}"
    else
        FILE_URL="https://github.com/pollen-robotics/reachy-mini-desktop-app/releases/download/v${VERSION}/${FILE_NAME}"
    fi
fi

# Generate JSON
echo ""
echo -e "${BLUE}ðŸ“„ Generating update metadata...${NC}"

JSON_DIR="$OUTPUT_DIR/$PLATFORM/$VERSION"
mkdir -p "$JSON_DIR"

UPDATE_JSON="$JSON_DIR/update.json"
cat > "$UPDATE_JSON" <<EOF
{
  "version": "${VERSION}",
  "notes": "Update for version ${VERSION}",
  "pub_date": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
  "platforms": {
    "${PLATFORM}": {
      "signature": "${SIGNATURE}",
      "url": "${FILE_URL}"
    }
  }
}
EOF

echo -e "${GREEN}âœ… Metadata created: ${UPDATE_JSON}${NC}"

# Summary
echo ""
echo -e "${GREEN}====================================${NC}"
echo -e "${GREEN}âœ… Update build completed!${NC}"
echo -e "${GREEN}====================================${NC}"
echo ""
echo -e "${BLUE}Files:${NC}"
echo "  - Updater artifact: ${OUTPUT_DIR}/${FILE_NAME}"
echo "  - Signature: ${OUTPUT_DIR}/${FILE_NAME}.sig"
echo "  - Metadata: ${UPDATE_JSON}"
echo "  - Download URL: ${FILE_URL}"
echo ""

if [ "$ENV" = "dev" ]; then
    echo -e "${BLUE}To test locally:${NC}"
    echo "  1. Start server: cd ${OUTPUT_DIR} && python3 -m http.server 8080"
    echo "  2. Run app and check for updates"
fi
